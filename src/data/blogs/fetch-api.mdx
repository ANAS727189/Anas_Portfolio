---
title: "Modern API Data Fetching in React: A Comprehensive Guide"
description: "Explore modern methods for fetching data in React, including Fetch API, Axios, useFetch Hook, TanStack Query, and SWR, with practical examples and optimizations."
image: "/fetch-api.webp"
date: "2025-05-13"
tags: ["coding", "react", "programming"]
isPublished: true
author: "Anas"
---

Fetching data is a cornerstone of dynamic React applications. As the React ecosystem evolves, developers have access to a variety of tools and techniques to handle API calls efficiently, ensuring scalability, performance, and a seamless user experience. This guide explores modern data-fetching methods in React, including the native **Fetch API**, **Axios**, the `useFetch` Hook, **TanStack Query**, and **SWR**, complete with practical examples, edge cases, and optimization strategies.

<Callout type="info">
  **Why Data Fetching Matters**: Efficient data fetching enhances user experience by minimizing load times, handling errors gracefully, and optimizing resource usage in React applications.
</Callout>

## Table of Contents

- [Understanding APIs](#understanding-apis)
- [API Calls in React](#api-calls-in-react)
- [Types of APIs](#types-of-apis)
- [HTTP Methods and Their Role](#http-methods-and-their-role)
- [APIs vs. Webhooks](#apis-vs-webhooks)
- [REST vs. HTTP](#rest-vs-http)
- [Fetching Data with the Fetch API](#fetching-data-with-the-fetch-api)
- [Using Axios for Data Fetching](#using-axios-for-data-fetching)
- [Simplifying with useFetch Hook](#simplifying-with-usefetch-hook)
- [Optimizing with TanStack Query](#optimizing-with-tanstack-query)
- [Fetching with SWR](#fetching-with-swr)
- [Conclusion](#conclusion)

---

## Understanding APIs

An **Application Programming Interface (API)** is a set of rules and protocols that facilitates communication between different software systems. Think of an API as a bridge that allows your React application (the client) to request and receive data from a backend server or third-party service.

### Why APIs?

- **Simplified Development**: APIs allow developers to leverage existing data or functionality without building everything from scratch. For example, a weather app can use a third-party API to fetch real-time forecasts.
- **Innovation**: APIs enable enterprises to open their products for faster integration and innovation, such as apps posting to social media platforms via their APIs.
- **Productization**: APIs can be standalone products, like Stripe’s payment APIs or Twilio’s messaging APIs.

### Types of APIs

1. **Hardware APIs**: Interfaces for software to communicate with hardware, e.g., a phone’s camera interacting with the operating system.
2. **Software Library APIs**: Interfaces for consuming code from another codebase, e.g., using methods from an imported library.
3. **Web APIs**: Interfaces for communication over a network, e.g., fetching stock prices from a finance API.

### API Protocols and Styles

- **REST (Representational State Transfer)**: Uses HTTP methods and typically returns JSON.
- **GraphQL**: A query language allowing clients to request specific data.
- **SOAP (Simple Object Access Protocol)**: XML-based, designed for secure enterprise applications.
- **WebSockets**: Enables real-time, bidirectional communication.
- **Webhooks**: Event-driven HTTP callbacks.
- **gRPC**: High-performance RPC framework by Google.
- **MQTT**: Lightweight messaging protocol for IoT.

### Real-Life Analogy

Imagine an API as a waiter in a restaurant:
- The customer (client) places an order (request) through the waiter (API).
- The waiter delivers the order to the kitchen (server).
- The kitchen prepares the food and returns it via the waiter (response).

<Callout type="tip">
  APIs simplify integration by providing a standardized way to access data or functionality, much like a waiter streamlines communication between the customer and the kitchen.
</Callout>

---

## API Calls in React

An **API call** in React involves sending a request from the client (your app) to a server and handling the response. Key considerations include:

- **State Management**: Storing fetched data in component state.
- **Loading State**: Displaying feedback during data fetching.
- **Error Handling**: Gracefully managing errors.
- **Optimizations**: Caching, deduplication, and preventing race conditions.

<Callout type="best-practice">
  Always manage loading and error states in your components to provide a smooth user experience and avoid rendering issues during API calls.
</Callout>

---

## Types of APIs

### 1. SOAP (Simple Object Access Protocol)

- **Overview**: A protocol using XML for structured data exchange, designed for enterprise applications.
- **Key Features**:
  - Operates over HTTP, SMTP, or TCP.
  - Uses XML for messages.
  - Includes built-in security (WS-Security) and reliability features.
  - Can be stateful or stateless.
- **Use Cases**: Banking, financial services, and government applications.
- **Pros**: Robust security, standardized, versatile transport protocols.
- **Cons**: Verbose, complex, and heavy due to XML.

### 2. REST (Representational State Transfer)

- **Overview**: An architectural style using HTTP to manage resources identified by URIs.
- **Key Features**:
  - Operates over HTTP with JSON as the primary format.
  - Stateless, with each request independent.
  - Supports caching and layered systems.
- **Use Cases**: Web apps, mobile apps, microservices.
- **Pros**: Lightweight, flexible, scalable.
- **Cons**: Lacks built-in security, may lead to over- or under-fetching.

### 3. GraphQL

- **Overview**: A query language allowing clients to request specific data via a single endpoint.
- **Key Features**:
  - Uses JSON for requests and responses.
  - Strongly typed with a schema.
  - Stateless, similar to REST.
- **Use Cases**: Mobile and single-page apps with complex data needs.
- **Pros**: Efficient, reduces over-fetching, single endpoint.
- **Cons**: Complex setup, challenging caching, potential performance issues.

### Comparison Table

<img src="/doff=comparison.webp" alt="Comparison Table"/>

<Callout type="info">
  Choose REST for most web and mobile apps due to its simplicity and scalability. Use GraphQL for complex data needs and SOAP for enterprise-grade security requirements.
</Callout>

---

## HTTP Methods and Their Role

HTTP methods define the actions performed via APIs:

1. **GET**: Retrieve data.
2. **POST**: Create a new resource.
3. **PUT**: Update or replace an existing resource.
4. **PATCH**: Partially update a resource.
5. **DELETE**: Remove a resource.

### POST vs. PUT vs. PATCH

- **POST**:
  - Creates a new resource.
  - Non-idempotent (multiple requests create multiple resources).
  - Example:
    <CodeBlock language="json">
    ```json
    POST /users
    {
      "name": "John Doe",
      "email": "john@example.com"
    }
    ```
    </CodeBlock>

- **PUT**:
  - Replaces an entire resource.
  - Idempotent (same request yields same result).
  - Example:
    <CodeBlock language="json">
    ```json
    PUT /users/1
    {
      "name": "John Doe",
      "email": "john.updated@example.com"
    }
    ```
    </CodeBlock>

- **PATCH**:
  - Updates specific fields of a resource.
  - Idempotent.
  - Example:
    <CodeBlock language="json">
    ```json
    PATCH /users/1
    {
      "email": "john.updated@example.com"
    }
    ```
    </CodeBlock>

### Other HTTP Methods

- **HEAD**: Retrieves headers without the response body.
- **OPTIONS**: Describes supported HTTP methods for a resource.
- **CONNECT**: Establishes a tunnel (e.g., for HTTPS).
- **TRACE**: Performs a loop-back test for debugging.
- **LINK/UNLINK**: Manages resource relationships (rare).

<Callout type="tip">
  Use **POST** for creating resources, **PUT** for full updates, and **PATCH** for partial updates to ensure clear intent and idempotency where needed.
</Callout>

---

## APIs vs. Webhooks

**Webhooks** are HTTP-based callbacks for event-driven communication. Unlike APIs, where the client initiates requests, webhooks allow servers to push data to clients when events occur. They are often called “reverse APIs” or “push APIs” but work alongside APIs, not as replacements.

<Callout type="info">
  Webhooks are ideal for real-time updates, such as receiving notifications from a payment gateway or a messaging platform.
</Callout>

---

## REST vs. HTTP

REST is an architectural style, not a protocol like HTTP. RESTful APIs adhere to six constraints:

1. **Client-Server Architecture**: Separates client and server concerns.
2. **Statelessness**: Each request is independent.
3. **Cacheability**: Responses can be cached to reduce server load.
4. **Layered System**: Supports intermediaries like proxies.
5. **Code on Demand** (optional): Servers can send executable code.
6. **Uniform Interface**: Includes resource identification, manipulation, self-descriptive messages, and hypermedia.

REST uses URIs to access resources and supports multiple formats (JSON, XML, etc.). While HTTP is common, REST is protocol-agnostic.

<Callout type="best-practice">
  Design RESTful APIs with clear resource-based URIs and consistent HTTP methods to ensure scalability and ease of use.
</Callout>

---

## Fetching Data with the Fetch API

The **Fetch API** is a native browser API for making HTTP requests, supporting various methods like GET, POST, PUT, and DELETE.

### Basic Syntax

<CodeBlock language="javascript">
```javascript
fetch(url, options)
```
</CodeBlock>

For a **GET** request:

<CodeBlock language="javascript">
```javascript
fetch(url)
```
</CodeBlock>

For a **POST** request:

<CodeBlock language="javascript">
```javascript
fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({}),
})
```
</CodeBlock>

<Callout type="info">
  The Fetch API is built into modern browsers, eliminating the need for external dependencies for basic HTTP requests.
</Callout>

### Fetching a List of Posts

Using the [JSONPlaceholder API](https://jsonplaceholder.typicode.com):

<CodeBlock language="jsx">
```jsx
import { useEffect, useState } from 'react';
import { NavLink } from 'react-router-dom';

const FetchGetRequest = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchDataForPosts = async () => {
      try {
        const response = await fetch(
          'https://jsonplaceholder.typicode.com/posts?_limit=8'
        );
        if (!response.ok) {
          throw new Error(`HTTP error: Status ${response.status}`);
        }
        const postsData = await response.json();
        setData(postsData);
        setError(null);
      } catch (err) {
        setError(err.message);
        setData(null);
      } finally {
        setLoading(false);
      }
    };

    fetchDataForPosts();
  }, []);

  return (
    <div className="flex">
      <div className="w-52 sm:w-80 flex justify-center items-center">
        {loading && <div className="text-xl font-medium">Loading posts...</div>}
        {error && <div className="text-red-700">{error}</div>}
        <ul>
          {data &&
            data.map(({ id, title }) => (
              <li key={id} className="border-b border-gray-100 text-sm sm:text-base">
                <NavLink
                  className={({ isActive }) =>
                    isActive
                      ? 'p-4 block hover:bg-gray-100 bg-gray-100'
                      : 'p-4 block hover:bg-gray-100'
                  }
                  to={`/posts/${id}`}
                >
                  {title}
                </NavLink>
              </li>
            ))}
        </ul>
      </div>
      <div className="bg-gray-100 flex-1 p-4 min-h-[550px]">
        Single post here...
      </div>
    </div>
  );
};

export default FetchGetRequest;
```
</CodeBlock>

### Why useEffect?

Data fetching is a side effect and should be isolated from rendering logic. `useEffect` ensures requests occur after the component mounts.

<Callout type="best-practice">
  Always use `useEffect` for data fetching to avoid side effects during rendering and ensure proper lifecycle management.
</Callout>

### Handling Responses

The Fetch API returns a **Response** object, requiring `response.json()` for JSON data. Check `response.ok` for HTTP errors, as `fetch` only rejects on network failures.

<Callout type="tip">
  Always check `response.ok` to handle HTTP errors (e.g., 404, 500), as `fetch` does not throw errors for these cases by default.
</Callout>

### Extracting Fetch Logic

<CodeBlock language="javascript">
```javascript
export const getRequestWithNativeFetch = async (url) => {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`HTTP error: Status ${response.status}`);
  }
  return response.json();
};
```
</CodeBlock>

Usage:

<CodeBlock language="jsx">
```jsx
useEffect(() => {
  const fetchDataForPosts = async () => {
    try {
      const postsData = await getRequestWithNativeFetch(
        'https://jsonplaceholder.typicode.com/posts?_limit=8'
      );
      setData(postsData);
      setError(null);
    } catch (err) {
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  };

  fetchDataForPosts();
}, []);
```
</CodeBlock>

### Fetching a Single Post

<CodeBlock language="jsx">
```jsx
useEffect(() => {
  const fetchSinglePost = async () => {
    try {
      const postData = await getRequestWithNativeFetch(
        `https://jsonplaceholder.typicode.com/posts/${postId}`
      );
      setData(postData);
      setError(null);
    } catch (err) {
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  };

  fetchSinglePost();
}, [postId]);
```
</CodeBlock>

Render:

<CodeBlock language="jsx">
```jsx
return (
  <>
    {loading && <div className="text-xl font-medium">A moment please...</div>}
    {error && <div className="text-red-700">{error}</div>}
    <article>
      <h1 className="text-xl md:text-2xl font-medium mb-6">{data?.title}</h1>
      <p>{data?.body}</p>
    </article>
  </>
);
```
</CodeBlock>

### Handling Race Conditions

Use `AbortController` to cancel outdated requests:

<CodeBlock language="jsx">
```jsx
useEffect(() => {
  const controller = new AbortController();

  const fetchSinglePost = async () => {
    try {
      const postData = await getRequestWithNativeFetch(
        `https://jsonplaceholder.typicode.com/posts/${postId}`,
        { signal: controller.signal }
      );
      setData(postData);
      setError(null);
    } catch (err) {
      if (err.name === 'AbortError') {
        console.log('Aborted');
        return;
      }
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  };

  fetchSinglePost();

  return () => controller.abort();
}, [postId]);
```
</CodeBlock>

Updated fetch function:

<CodeBlock language="javascript">
```javascript
export const getRequestWithNativeFetch = async (url, { signal } = {}) => {
  const response = await fetch(url, { signal });
  if (!response.ok) {
    throw new Error(`HTTP error: Status ${response.status}`);
  }
  return response.json();
};
```
</CodeBlock>

<Callout type="best-practice">
  Use `AbortController` to prevent race conditions in dynamic components, ensuring only the latest request’s data is rendered.
</Callout>

### POST Requests with Fetch

<CodeBlock language="jsx">
```jsx
useEffect(() => {
  const fetchDataForPosts = async () => {
    try {
      const postsData = await postRequestWithFetch({
        userId: 11,
        id: 101,
        title: 'New post title',
        body: 'The post body content',
      });
      setData(postsData);
      setError(null);
    } catch (err) {
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  };

  fetchDataForPosts();
}, []);
```
</CodeBlock>

Fetch function:

<CodeBlock language="javascript">
```javascript
export const postRequestWithFetch = async (data) => {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(data),
  });
  return response.json();
};
```
</CodeBlock>

Render:

<CodeBlock language="jsx">
```jsx
return (
  <div className="py-12 px-3">
    <h2 className="text-2xl font-medium mb-6 underline">Post Request with Fetch</h2>
    {loading && <div className="text-xl font-medium">Loading...</div>}
    {error && <div className="text-red-700">{error}</div>}
    {data && (
      <div>
        <h2 className="text-xl font-medium mb-6">{data.title}</h2>
        <p className="mb-2">{data.body}</p>
        <span className="text-gray-700 text-sm">Post ID: {data.id}</span>
      </div>
    )}
  </div>
);
```
</CodeBlock>

---

## Using Axios for Data Fetching

**Axios** is a promise-based HTTP client with a cleaner API and robust error handling.

### Installation

<CodeBlock language="bash">
```bash
npm install axios
```
</CodeBlock>

<Callout type="info">
  Axios automatically parses JSON responses and throws errors for HTTP status codes outside the 2xx range, simplifying error handling compared to the Fetch API.
</Callout>

### Fetching a List of Posts

<CodeBlock language="jsx">
```jsx
import { useEffect, useState } from 'react';
import { fetcherWithAxios } from '../lib/fetcherWithAxios';

const FetchWithAxios = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchDataForPosts = async () => {
      try {
        const postsData = await fetcherWithAxios(
          'https://jsonplaceholder.typicode.com/posts?_limit=8'
        );
        setData(postsData);
        setError(null);
      } catch (err) {
        setError(err.message);
        setData(null);
      } finally {
        setLoading(false);
      }
    };

    fetchDataForPosts();
  }, []);

  return (
    <div className="flex">
      {loading && <div className="text-xl font-medium">Loading posts...</div>}
      {error && <div className="text-red-700">{error}</div>}
      <ul>
        {data &&
          data.map(({ id, title }) => (
            <li key={id} className="border-b border-gray-100 text-sm sm:text-base">
              <NavLink
                className={({ isActive }) =>
                  isActive
                    ? 'p-4 block hover:bg-gray-100 bg-gray-100'
                    : 'p-4 block hover:bg-gray-100'
                }
                to={`/posts/${id}`}
              >
                {title}
              </NavLink>
            </li>
          ))}
      </ul>
    </div>
  );
};

export default FetchWithAxios;
```
</CodeBlock>

Axios fetch function:

<CodeBlock language="javascript">
```javascript
import axios from 'axios';

export const fetcherWithAxios = async (url) => {
  const response = await axios.get(url);
  return response.data;
};
```
</CodeBlock>

### Fetching a Single Post

<CodeBlock language="jsx">
```jsx
useEffect(() => {
  const fetchSinglePost = async () => {
    try {
      const postData = await fetcherWithAxios(
        `https://jsonplaceholder.typicode.com/posts/${postId}`
      );
      setData(postData);
      setError(null);
    } catch (err) {
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  };

  fetchSinglePost();
}, [postId]);
```
</CodeBlock>

### POST Requests with Axios

<CodeBlock language="javascript">
```javascript
export const postRequestWithAxios = async (data) => {
  const response = await axios.post('https://jsonplaceholder.typicode.com/posts', data);
  return response.data;
};
```
</CodeBlock>

Usage:

<CodeBlock language="jsx">
```jsx
useEffect(() => {
  const fetchDataForPosts = async () => {
    try {
      const postsData = await postRequestWithAxios({
        userId: 11,
        id: 101,
        title: 'New post title',
        body: 'The post body content',
      });
      setData(postsData);
      setError(null);
    } catch (err) {
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  };

  fetchDataForPosts();
}, []);
```
</CodeBlock>

<Callout type="tip">
  Use Axios for projects requiring advanced features like request cancellation, interceptors, or automatic JSON parsing to reduce boilerplate code.
</Callout>

---

## Simplifying with useFetch Hook

The `useFetch` hook from `react-fetch-hook` simplifies Fetch API logic by handling state management.

### Installation

<CodeBlock language="bash">
```bash
npm install react-fetch-hook
```
</CodeBlock>

<Callout type="info">
  The `useFetch` hook abstracts away loading, error, and data states, making it ideal for simple data-fetching scenarios with minimal setup.
</Callout>

### Fetching a List of Posts

<CodeBlock language="jsx">
```jsx
import useFetch from 'react-fetch-hook';
import { NavLink } from 'react-router-dom';

const ReactFetchHook = () => {
  const { isLoading, data, error } = useFetch(
    'https://jsonplaceholder.typicode.com/posts?_limit=8'
  );

  return (
    <div className="flex">
      {isLoading && <div className="text-xl font-medium">A moment please...</div>}
      {error && <div className="text-red-700">{error.message}</div>}
      <ul>
        {data &&
          data.map(({ id, title }) => (
            <li key={id} className="border-b border-gray-100 text-sm sm:text-base">
              <NavLink
                className={({ isActive }) =>
                  isActive
                    ? 'p-4 block hover:bg-gray-100 bg-gray-100'
                    : 'p-4 block hover:bg-gray-100'
                }
                to={`/posts/${id}`}
              >
                {title}
              </NavLink>
            </li>
          ))}
      </ul>
    </div>
  );
};

export default ReactFetchHook;
```
</CodeBlock>

### Fetching a Single Post

<CodeBlock language="jsx">
```jsx
const { isLoading: loading, data, error } = useFetch(
  `https://jsonplaceholder.typicode.com/posts/${postId}`
);
```
</CodeBlock>

<Callout type="best-practice">
  Use `useFetch` for quick prototyping or small apps, but consider TanStack Query or SWR for advanced caching and revalidation needs in production.
</Callout>

---

## Optimizing with TanStack Query

**TanStack Query** simplifies data fetching with caching, deduplication, and re-fetching.

### Installation

<CodeBlock language="bash">
```bash
npm install @tanstack/react-query
```
</CodeBlock>

### Setup

In `main.jsx`:

<CodeBlock language="jsx">
```jsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { RouterProvider, createBrowserRouter } from 'react-router-dom';

const router = createBrowserRouter([/* routes */]);
const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <RouterProvider router={router} />
    </QueryClientProvider>
  </React.StrictMode>
);
```
</CodeBlock>

<Callout type="info">
  TanStack Query provides powerful features like caching, automatic refetching, and query invalidation, making it ideal for complex applications.
</Callout>

### Fetching a List of Posts

<CodeBlock language="jsx">
```jsx
import { useQuery } from '@tanstack/react-query';
import { fetcherWithFetch } from '../lib/fetcherWithFetch';
import { NavLink } from 'react-router-dom';

const ReactQuery = () => {
  const { data, error, isPending: loading } = useQuery({
    queryKey: ['posts'],
    queryFn: () =>
      fetcherWithFetch('https://jsonplaceholder.typicode.com/posts?_limit=8'),
  });

  return (
    <div className="flex">
      {loading && <div className="text-xl font-medium">Loading posts...</div>}
      {error && <div className="text-red-700">{error.message}</div>}
      <ul>
        {data &&
          data.map(({ id, title }) => (
            <li key={id} className="border-b border-gray-100 text-sm sm:text-base">
              <NavLink
                className={({ isActive }) =>
                  isActive
                    ? 'p-4 block hover:bg-gray-100 bg-gray-100'
                    : 'p-4 block hover:bg-gray-100'
                }
                to={`/posts/${id}`}
              >
                {title}
              </NavLink>
            </li>
          ))}
      </ul>
    </div>
  );
};

export default ReactQuery;
```
</CodeBlock>

Fetch function:

<CodeBlock language="javascript">
```javascript
export const fetcherWithFetch = async (url) => {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`HTTP error: Status ${response.status}`);
  }
  return response.json();
};
```
</CodeBlock>

### Fetching a Single Post

<CodeBlock language="jsx">
```jsx
const { data, error, isPending: loading } = useQuery({
  queryKey: ['post', parseInt(postId)],
  queryFn: () =>
    fetcherWithFetch(`https://jsonplaceholder.typicode.com/posts/${postId}`),
  staleTime: 1000 * 60 * 10,
});
```
</CodeBlock>

### Using Axios with TanStack Query

<CodeBlock language="jsx">
```jsx
const { data, error, isPending: loading } = useQuery({
  queryKey: ['posts'],
  queryFn: () =>
    fetcherWithAxios('https://jsonplaceholder.typicode.com/posts?_limit=8'),
});
```
</CodeBlock>

<Callout type="tip">
  Configure `staleTime` in TanStack Query to control how long cached data remains fresh, reducing unnecessary API calls.
</Callout>

---

## Fetching with SWR

**SWR** (stale-while-revalidate) offers lightweight data fetching with caching and revalidation.

### Installation

<CodeBlock language="bash">
```bash
npm install swr
```
</CodeBlock>

<Callout type="info">
  SWR’s stale-while-revalidate strategy provides instant UI updates with cached data while fetching fresh data in the background.
</Callout>

### Fetching a List of Posts

<CodeBlock language="jsx">
```jsx
import useSWR from 'swr';
import { fetcherWithFetch } from '../lib/fetcherWithFetch';
import { NavLink } from 'react-router-dom';

const FetchWithSwr = () => {
  const { data, error, isLoading } = useSWR(
    'https://jsonplaceholder.typicode.com/posts?_limit=8',
    fetcherWithFetch
  );

  return (
    <div className="flex">
      {isLoading && <div className="text-xl font-medium">Loading posts...</div>}
      {error && <div className="text-red-700">{error.message}</div>}
      <ul>
        {data &&
          data.map(({ id, title }) => (
            <li key={id} className="border-b border-gray-100 text-sm sm:text-base">
              <NavLink
                className={({ isActive }) =>
                  isActive
                    ? 'p-4 block hover:bg-gray-100 bg-gray-100'
                    : 'p-4 block hover:bg-gray-100'
                }
                to={`/posts/${id}`}
              >
                {title}
              </NavLink>
            </li>
          ))}
      </ul>
    </div>
  );
};

export default FetchWithSwr;
```
</CodeBlock>

### Fetching a Single Post

<CodeBlock language="jsx">
```jsx
const { data, error, isLoading: loading } = useSWR(
  `https://jsonplaceholder.typicode.com/posts/${postId}`,
  fetcherWithFetch,
  {
    dedupingInterval: 1000 * 60 * 10,
  }
);
```
</CodeBlock>

<Callout type="best-practice">
  Use SWR’s `dedupingInterval` to prevent duplicate requests within a specified time, optimizing performance for frequently accessed endpoints.
</Callout>

---

## Conclusion

This guide explored modern data-fetching techniques in React, covering the **Fetch API**, **Axios**, the `useFetch` hook, **TanStack Query**, and **SWR**. Each method offers unique benefits:

- **Fetch API**: Native, lightweight, but requires manual error handling.
- **Axios**: Simplified API with automatic JSON parsing and robust error handling.
- **useFetch Hook**: Reduces boilerplate for simple apps.
- **TanStack Query**: Ideal for complex apps with caching and deduplication.
- **SWR**: Lightweight, with built-in caching and revalidation.

Choose the method that best suits your project’s needs, balancing simplicity, performance, and scalability. Experiment with the [JSONPlaceholder API](https://jsonplaceholder.typicode.com) to practice these techniques, and refer to the official documentation for [Axios](https://axios-http.com), [TanStack Query](https://tanstack.com/query), and [SWR](https://swr.vercel.app) for deeper insights.

<Callout type="info">
  **Editor's Note**: For further learning, explore the [React documentation](https://reactjs.org) and test these methods with public APIs to enhance your skills.
</Callout>
```